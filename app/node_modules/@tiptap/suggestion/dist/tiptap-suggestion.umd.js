(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('prosemirror-state'), require('prosemirror-view')) :
  typeof define === 'function' && define.amd ? define(['exports', 'prosemirror-state', 'prosemirror-view'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['@tiptap/suggestion'] = {}, global.prosemirrorState, global.prosemirrorView));
}(this, (function (exports, prosemirrorState, prosemirrorView) { 'use strict';

  function findSuggestionMatch(config) {
      const { char, allowSpaces, startOfLine, $position, } = config;
      // Matching expressions used for later
      const escapedChar = `\\${char}`;
      const suffix = new RegExp(`\\s${escapedChar}$`);
      const prefix = startOfLine ? '^' : '';
      const regexp = allowSpaces
          ? new RegExp(`${prefix}${escapedChar}.*?(?=\\s${escapedChar}|$)`, 'gm')
          : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\s${escapedChar}]*`, 'gm');
      const isTopLevelNode = $position.depth <= 0;
      const textFrom = isTopLevelNode
          ? 0
          : $position.before();
      const textTo = $position.pos;
      const text = $position.doc.textBetween(textFrom, textTo, '\0', '\0');
      const match = Array.from(text.matchAll(regexp)).pop();
      if (!match || match.input === undefined || match.index === undefined) {
          return null;
      }
      // JavaScript doesn't have lookbehinds; this hacks a check that first character is " "
      // or the line beginning
      const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);
      if (!/^[\s\0]?$/.test(matchPrefix)) {
          return null;
      }
      // The absolute position of the match in the document
      const from = match.index + $position.start();
      let to = from + match[0].length;
      // Edge case handling; if spaces are allowed and we're directly in between
      // two triggers
      if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {
          match[0] += ' ';
          to += 1;
      }
      // If the $position is located within the matched substring, return that range
      if (from < $position.pos && to >= $position.pos) {
          return {
              range: {
                  from,
                  to,
              },
              query: match[0].slice(char.length),
              text: match[0],
          };
      }
      return null;
  }

  function Suggestion({ editor, char = '@', allowSpaces = false, startOfLine = false, decorationTag = 'span', decorationClass = 'suggestion', command = () => null, items = () => [], render = () => ({}), allow = () => true, }) {
      const renderer = render === null || render === void 0 ? void 0 : render();
      return new prosemirrorState.Plugin({
          key: new prosemirrorState.PluginKey('suggestion'),
          view() {
              return {
                  update: async (view, prevState) => {
                      var _a, _b, _c, _d, _e;
                      const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);
                      const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);
                      // See how the state changed
                      const moved = prev.active && next.active && prev.range.from !== next.range.from;
                      const started = !prev.active && next.active;
                      const stopped = prev.active && !next.active;
                      const changed = !started && !stopped && prev.query !== next.query;
                      const handleStart = started || moved;
                      const handleChange = changed && !moved;
                      const handleExit = stopped || moved;
                      // Cancel when suggestion isn't active
                      if (!handleStart && !handleChange && !handleExit) {
                          return;
                      }
                      const state = handleExit ? prev : next;
                      const decorationNode = document.querySelector(`[data-decoration-id="${state.decorationId}"]`);
                      const props = {
                          editor,
                          range: state.range,
                          query: state.query,
                          text: state.text,
                          items: (handleChange || handleStart)
                              ? await items(state.query)
                              : [],
                          command: commandProps => {
                              command({
                                  editor,
                                  range: state.range,
                                  props: commandProps,
                              });
                          },
                          decorationNode,
                          // virtual node for popper.js or tippy.js
                          // this can be used for building popups without a DOM node
                          clientRect: decorationNode
                              ? () => decorationNode.getBoundingClientRect()
                              : null,
                      };
                      if (handleExit) {
                          (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _c === void 0 ? void 0 : _c.call(renderer, props);
                      }
                      if (handleChange) {
                          (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);
                      }
                      if (handleStart) {
                          (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _e === void 0 ? void 0 : _e.call(renderer, props);
                      }
                  },
              };
          },
          state: {
              // Initialize the plugin's internal state.
              init() {
                  return {
                      active: false,
                      range: {},
                      query: null,
                      text: null,
                  };
              },
              // Apply changes to the plugin state from a view transaction.
              apply(transaction, prev) {
                  const { selection } = transaction;
                  const next = { ...prev };
                  // We can only be suggesting if there is no selection
                  if (selection.from === selection.to) {
                      // Reset active state if we just left the previous suggestion range
                      if (selection.from < prev.range.from || selection.from > prev.range.to) {
                          next.active = false;
                      }
                      // Try to match against where our cursor currently is
                      const match = findSuggestionMatch({
                          char,
                          allowSpaces,
                          startOfLine,
                          $position: selection.$from,
                      });
                      const decorationId = `id_${Math.floor(Math.random() * 0xFFFFFFFF)}`;
                      // If we found a match, update the current state to show it
                      if (match && allow({ editor, range: match.range })) {
                          next.active = true;
                          next.decorationId = prev.decorationId ? prev.decorationId : decorationId;
                          next.range = match.range;
                          next.query = match.query;
                          next.text = match.text;
                      }
                      else {
                          next.active = false;
                      }
                  }
                  else {
                      next.active = false;
                  }
                  // Make sure to empty the range if suggestion is inactive
                  if (!next.active) {
                      next.decorationId = null;
                      next.range = {};
                      next.query = null;
                      next.text = null;
                  }
                  return next;
              },
          },
          props: {
              // Call the keydown hook if suggestion is active.
              handleKeyDown(view, event) {
                  var _a;
                  const { active, range } = this.getState(view.state);
                  if (!active) {
                      return false;
                  }
                  return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;
              },
              // Setup decorator on the currently active suggestion.
              decorations(state) {
                  const { active, range, decorationId } = this.getState(state);
                  if (!active) {
                      return null;
                  }
                  return prosemirrorView.DecorationSet.create(state.doc, [
                      prosemirrorView.Decoration.inline(range.from, range.to, {
                          nodeName: decorationTag,
                          class: decorationClass,
                          'data-decoration-id': decorationId,
                      }),
                  ]);
              },
          },
      });
  }

  exports.Suggestion = Suggestion;
  exports.default = Suggestion;
  exports.findSuggestionMatch = findSuggestionMatch;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=tiptap-suggestion.umd.js.map
